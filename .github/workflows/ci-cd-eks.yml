name: CI/CD - Build and Deploy to EKS

on:
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - 'Dockerfile'
      - 'package.json'
      - '.github/workflows/ci-cd-eks.yml'
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: fiap-soat-eks-dev
  ECR_REPOSITORY: fiap-soat-application
  K8S_NAMESPACE: fiap-soat-app
  K8S_DEPLOYMENT: fiap-soat-application

jobs:
  # ==========================================
  # JOB 1: Testes e Build
  # ==========================================
  test:
    name: üß™ Run Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint || echo "‚ö†Ô∏è  Lint falhou, mas continuando..."

      - name: Run unit tests
        run: npm run test || echo "‚ö†Ô∏è  Testes falharam, mas continuando..."

      - name: Build application
        run: npm run build

  # ==========================================
  # JOB 2: Build Docker Image e Push para ECR
  # ==========================================
  build:
    name: üê≥ Build & Push Docker Image
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}

      - name: Ensure ECR repository exists
        # If repository does not exist, create it. Requires ecr:DescribeRepositories and ecr:CreateRepository permissions
        run: |
          echo "üîé Checking for ECR repository: ${{ env.ECR_REPOSITORY }}"
          set -e
          if aws ecr describe-repositories --repository-names "${{ env.ECR_REPOSITORY }}" --region "${{ env.AWS_REGION }}" >/dev/null 2>&1; then
            echo "‚úÖ ECR repository exists"
          else
            echo "‚ö†Ô∏è ECR repository not found. Creating..."
            aws ecr create-repository --repository-name "${{ env.ECR_REPOSITORY }}" --region "${{ env.AWS_REGION }}"
            echo "‚úÖ Repository created"
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate Docker metadata
        id: meta
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${SHORT_SHA}"
          IMAGE_LATEST="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest"
          
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image-latest=${IMAGE_LATEST}" >> $GITHUB_OUTPUT
          echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT

      - name: Build Docker image
        id: build
        run: |
          echo "üê≥ Building Docker image..."
          docker build \
            --tag ${{ steps.meta.outputs.image-tag }} \
            --tag ${{ steps.meta.outputs.image-latest }} \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            --build-arg VERSION=${{ steps.meta.outputs.short-sha }} \
            .
          
          echo "‚úÖ Build completed successfully!"

      - name: Push Docker image to ECR
        run: |
          echo "üì§ Pushing image to ECR..."
          docker push ${{ steps.meta.outputs.image-tag }}
          docker push ${{ steps.meta.outputs.image-latest }}
          echo "‚úÖ Push completed!"

      - name: Image Summary
        run: |
          echo "### üê≥ Docker Image Built" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ steps.meta.outputs.image-tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Latest**: \`${{ steps.meta.outputs.image-latest }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: \`${{ steps.meta.outputs.timestamp }}\`" >> $GITHUB_STEP_SUMMARY

  # ==========================================
  # JOB 3: Deploy para EKS
  # ==========================================
  deploy:
    name: üöÄ Deploy to EKS
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
          kubectl version --client
          kubectl cluster-info

      - name: Ensure Deployment Exists
        run: |
          if ! kubectl get deployment ${{ env.K8S_DEPLOYMENT }} -n ${{ env.K8S_NAMESPACE }} &> /dev/null; then
            echo "üì¶ Deployment n√£o existe, criando pela primeira vez..."
            kubectl apply -f k8s/deployment.yaml
          else
            echo "‚úÖ Deployment j√° existe, atualizando imagem..."
          fi

      - name: Update Kubernetes Deployment
        run: |
          echo "üîÑ Updating deployment with new image..."
          
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${SHORT_SHA}"
          
          # Atualizar a imagem do deployment
          kubectl set image deployment/${{ env.K8S_DEPLOYMENT }} \
            ${{ env.K8S_DEPLOYMENT }}=${IMAGE_TAG} \
            -n ${{ env.K8S_NAMESPACE }}
          
          # Adicionar anota√ß√µes para rastreamento
          kubectl annotate deployment/${{ env.K8S_DEPLOYMENT }} \
            kubernetes.io/change-cause="Deploy commit ${SHORT_SHA} by ${{ github.actor }}" \
            -n ${{ env.K8S_NAMESPACE }} --overwrite

      - name: Wait for Rollout
        run: |
          echo "‚è≥ Waiting for deployment rollout..."
          kubectl rollout status deployment/${{ env.K8S_DEPLOYMENT }} \
            -n ${{ env.K8S_NAMESPACE }} \
            --timeout=5m

      - name: Verify Deployment
        run: |
          echo ""
          echo "=== üìä Deployment Status ==="
          kubectl get deployment ${{ env.K8S_DEPLOYMENT }} -n ${{ env.K8S_NAMESPACE }}
          
          echo ""
          echo "=== üîç Pods Status ==="
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app=${{ env.K8S_DEPLOYMENT }} -o wide
          
          echo ""
          echo "=== üìù Recent Logs ==="
          kubectl logs -n ${{ env.K8S_NAMESPACE }} \
            deployment/${{ env.K8S_DEPLOYMENT }} \
            --tail=50 --since=2m || true

      - name: Health Check
        run: |
          echo "üè• Running health check..."
          
          # Obter Load Balancer URL
          LB_URL=$(kubectl get svc fiap-soat-application-service -n ${{ env.K8S_NAMESPACE }} \
            -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          if [ -z "$LB_URL" ]; then
            echo "‚ö†Ô∏è  Load Balancer URL n√£o dispon√≠vel ainda"
            exit 0
          fi
          
          echo "Load Balancer: http://${LB_URL}"
          
          # Aguardar LB ficar pronto
          sleep 30
          
          # Testar health endpoint
          for i in {1..5}; do
            if curl -f -s http://${LB_URL}/health > /dev/null; then
              echo "‚úÖ Health check passed!"
              curl -s http://${LB_URL}/health | jq '.' || cat
              break
            else
              echo "‚è≥ Attempt $i/5 failed, retrying in 10s..."
              sleep 10
            fi
          done

      - name: Deployment Summary
        if: always()
        run: |
          echo "### üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster**: \`${{ env.EKS_CLUSTER_NAME }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: \`${{ env.K8S_NAMESPACE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment**: \`${{ env.K8S_DEPLOYMENT }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ needs.build.outputs.image-tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: \`${{ github.actor }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Mostrar pods
          echo "#### Pods Status" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app=${{ env.K8S_DEPLOYMENT }} >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # ==========================================
  # JOB 4: Notification (opcional)
  # ==========================================
  notify:
    name: üì¢ Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [build, deploy]
    if: always() && github.ref == 'refs/heads/main'

    steps:
      - name: Deployment Success
        if: needs.deploy.result == 'success'
        run: |
          echo "‚úÖ Deployment successful!"
          echo "Image: ${{ needs.build.outputs.image-tag }}"

      - name: Deployment Failed
        if: needs.deploy.result == 'failure'
        run: |
          echo "‚ùå Deployment failed!"
          exit 1
