# üîÑ Estrat√©gia CI/CD - An√°lise de Alinhamento

**Data**: Janeiro 2025  
**Objetivo**: Garantir que os workflows dos reposit√≥rios EKS e Application estejam 100% alinhados

---

## üìä An√°lise dos Workflows Existentes

### 1. **Workflow EKS** (`fiap-soat-k8s-terraform/.github/workflows/deploy-app.yml`)

```yaml
Trigger: 
  - Push para main (paths: manifests/**, workflow)
  - workflow_dispatch (manual)

Responsabilidades:
  ‚úÖ Aplicar manifests Kubernetes (namespace, configmap, secret, deployment, service)
  ‚úÖ Aguardar rollout (kubectl rollout status)
  ‚úÖ Verificar deployment (pods, services, logs, events)
  ‚úÖ Health check via port-forward

Nome do Deployment: fiap-soat-nestjs
Namespace: fiap-soat-app
```

### 2. **Workflow Application** (`fiap-soat-application/.github/workflows/ci-cd-eks.yml`)

```yaml
Trigger:
  - Push para main (paths: src/**, Dockerfile, package.json)
  - Pull Request para main
  - workflow_dispatch (manual)

Responsabilidades:
  ‚úÖ Testes (unit, lint) - apenas em PR
  ‚úÖ Build Docker image
  ‚úÖ Push para ECR (tag: short-sha e latest)
  ‚úÖ Deploy no EKS (kubectl set image)
  ‚úÖ Aguardar rollout
  ‚úÖ Health check via Load Balancer

Nome do Deployment: fiap-soat-application
Namespace: fiap-soat-app
```

---

## ‚ö†Ô∏è **PROBLEMAS IDENTIFICADOS:**

### 1. **Nomes de Deployment Diferentes** ‚ùå

```diff
# Repo EKS (deploy-app.yml):
- kubectl rollout status deployment/fiap-soat-nestjs

# Repo Application (ci-cd-eks.yml):
+ kubectl set image deployment/fiap-soat-application
```

**Problema**: Os workflows referenciam nomes de deployment diferentes!

**Impacto**: 
- Workflow do EKS n√£o vai atualizar o deployment correto
- Pode criar 2 deployments no mesmo namespace
- Confus√£o sobre qual √© o deployment real

---

### 2. **Manifests vs. kubectl set image** ‚ö†Ô∏è

**Repo EKS**:
```bash
kubectl apply -f deployment.yaml  # Aplica manifest com imagem hardcoded
```

**Repo Application**:
```bash
kubectl set image deployment/...  # Atualiza imagem dinamicamente
```

**Problema**: 
- Workflow EKS sempre vai aplicar a imagem que est√° no `deployment.yaml`
- Workflow Application atualiza a imagem via `kubectl set image`
- Se ambos rodarem, a imagem do manifest vai sobrescrever a do CI/CD

---

### 3. **Ordem de Execu√ß√£o N√£o Definida** ‚ö†Ô∏è

Se ambos workflows rodarem ao mesmo tempo:
1. Workflow Application ‚Üí Build nova imagem ‚Üí Deploy
2. Workflow EKS ‚Üí Apply manifests ‚Üí Sobrescreve com imagem antiga

**Resultado**: Deploy da imagem nova √© perdido!

---

## ‚úÖ **SOLU√á√ÉO PROPOSTA:**

### **Estrat√©gia: Separa√ß√£o de Responsabilidades**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  REPO: fiap-soat-k8s-terraform                                  ‚îÇ
‚îÇ  WORKFLOW: deploy-app.yml                                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RESPONSABILIDADE:                                              ‚îÇ
‚îÇ    ‚Ä¢ Aplicar/Atualizar CONFIGURA√á√ïES (configmap, secret)        ‚îÇ
‚îÇ    ‚Ä¢ Aplicar/Atualizar ESTRUTURA (namespace, service)           ‚îÇ
‚îÇ    ‚Ä¢ N√ÉO aplicar deployment.yaml (deixar para o repo app)       ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  TRIGGER:                                                       ‚îÇ
‚îÇ    ‚Ä¢ Push para main em manifests/configmap.yaml                ‚îÇ
‚îÇ    ‚Ä¢ Push para main em manifests/secret.yaml                   ‚îÇ
‚îÇ    ‚Ä¢ Push para main em manifests/service.yaml                  ‚îÇ
‚îÇ    ‚Ä¢ workflow_dispatch (manual)                                 ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  A√á√ïES:                                                         ‚îÇ
‚îÇ    kubectl apply -f namespace.yaml                              ‚îÇ
‚îÇ    kubectl apply -f configmap.yaml                              ‚îÇ
‚îÇ    kubectl apply -f secret.yaml                                 ‚îÇ
‚îÇ    kubectl apply -f service.yaml                                ‚îÇ
‚îÇ    # N√ÉO aplicar deployment.yaml                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  REPO: fiap-soat-application                                    ‚îÇ
‚îÇ  WORKFLOW: ci-cd-eks.yml                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RESPONSABILIDADE:                                              ‚îÇ
‚îÇ    ‚Ä¢ Build da aplica√ß√£o (Docker image)                          ‚îÇ
‚îÇ    ‚Ä¢ Push para ECR                                              ‚îÇ
‚îÇ    ‚Ä¢ Deploy/Atualizar DEPLOYMENT com nova imagem                ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  TRIGGER:                                                       ‚îÇ
‚îÇ    ‚Ä¢ Push para main em src/**                                   ‚îÇ
‚îÇ    ‚Ä¢ Push para main em Dockerfile                               ‚îÇ
‚îÇ    ‚Ä¢ Push para main em package.json                             ‚îÇ
‚îÇ    ‚Ä¢ workflow_dispatch (manual)                                 ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  A√á√ïES:                                                         ‚îÇ
‚îÇ    docker build + push to ECR                                   ‚îÇ
‚îÇ    kubectl set image deployment/fiap-soat-application ...       ‚îÇ
‚îÇ    kubectl rollout status ...                                   ‚îÇ
‚îÇ    Health check                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üîß **MUDAN√áAS NECESS√ÅRIAS:**

### 1. **Padronizar Nome do Deployment** ‚úÖ

Escolher **UM** nome e usar em todos os lugares:

**Op√ß√£o Recomendada**: `fiap-soat-application`

```bash
# Arquivos a atualizar:
‚úÖ fiap-soat-k8s-terraform/manifests/deployment.yaml
   metadata.name: fiap-soat-application
   
‚úÖ fiap-soat-k8s-terraform/manifests/service.yaml
   spec.selector.app: fiap-soat-application
   
‚úÖ fiap-soat-k8s-terraform/.github/workflows/deploy-app.yml
   kubectl rollout status deployment/fiap-soat-application
```

---

### 2. **Atualizar Workflow EKS** ‚úÖ

```yaml
# deploy-app.yml - ANTES:
- name: Deploy Kubernetes Manifests
  run: |
    kubectl apply -f namespace.yaml
    kubectl apply -f configmap.yaml
    kubectl apply -f secret.yaml
    kubectl apply -f deployment.yaml  # ‚ùå REMOVER
    kubectl apply -f service.yaml

# deploy-app.yml - DEPOIS:
- name: Deploy Infrastructure Manifests
  run: |
    echo "üì¶ Aplicando manifests de infraestrutura..."
    kubectl apply -f namespace.yaml
    kubectl apply -f configmap.yaml
    kubectl apply -f secret.yaml
    kubectl apply -f service.yaml
    # deployment.yaml √© gerenciado pelo repo da aplica√ß√£o
```

---

### 3. **Criar/Atualizar deployment.yaml no Repo Application** ‚úÖ

Mover `deployment.yaml` para o repo da aplica√ß√£o:

```bash
# Estrutura:
fiap-soat-application/
‚îú‚îÄ‚îÄ .github/workflows/ci-cd-eks.yml
‚îú‚îÄ‚îÄ k8s/
‚îÇ   ‚îî‚îÄ‚îÄ deployment.yaml          # ‚Üê Manifest do deployment
‚îú‚îÄ‚îÄ src/
‚îú‚îÄ‚îÄ Dockerfile
‚îî‚îÄ‚îÄ package.json
```

**Vantagens**:
- Deployment fica junto com o c√≥digo
- Facilita sincroniza√ß√£o entre c√≥digo e deploy
- Evita conflitos entre workflows

---

### 4. **Atualizar Workflow Application para Criar Deployment na Primeira Vez** ‚úÖ

```yaml
# ci-cd-eks.yml - Adicionar step:
- name: Ensure Deployment Exists
  run: |
    if ! kubectl get deployment ${{ env.K8S_DEPLOYMENT }} -n ${{ env.K8S_NAMESPACE }} &> /dev/null; then
      echo "üì¶ Deployment n√£o existe, criando pela primeira vez..."
      kubectl apply -f k8s/deployment.yaml
    else
      echo "‚úÖ Deployment j√° existe, atualizando imagem..."
    fi

- name: Update Deployment Image
  run: |
    kubectl set image deployment/${{ env.K8S_DEPLOYMENT }} ...
```

---

## üìã **CHECKLIST DE IMPLEMENTA√á√ÉO:**

### Fase 1: Padroniza√ß√£o de Nomes
- [ ] Atualizar `manifests/deployment.yaml` ‚Üí `fiap-soat-application`
- [ ] Atualizar `manifests/service.yaml` ‚Üí selector: `fiap-soat-application`
- [ ] Atualizar workflow EKS ‚Üí `fiap-soat-application`

### Fase 2: Separa√ß√£o de Responsabilidades
- [ ] Remover `deployment.yaml` do workflow EKS
- [ ] Mover `deployment.yaml` para repo da aplica√ß√£o (pasta `k8s/`)
- [ ] Atualizar workflow Application para criar deployment se n√£o existir

### Fase 3: Valida√ß√£o
- [ ] Testar workflow EKS (deve aplicar configs, n√£o deployment)
- [ ] Testar workflow Application (deve criar/atualizar deployment)
- [ ] Verificar que ambos workflows n√£o conflitam

---

## üéØ **FLUXO COMPLETO AP√ìS IMPLEMENTA√á√ÉO:**

### **Cen√°rio 1: Mudan√ßa de Configura√ß√£o (configmap, secret)**

```bash
1. Dev altera manifests/configmap.yaml
2. Push para main no repo EKS
3. Workflow deploy-app.yml executa:
   ‚úÖ kubectl apply -f configmap.yaml
   ‚úÖ kubectl apply -f secret.yaml
   ‚è≠Ô∏è  N√£o toca no deployment
4. Dev precisa fazer rollout manual:
   kubectl rollout restart deployment/fiap-soat-application -n fiap-soat-app
```

### **Cen√°rio 2: Mudan√ßa de C√≥digo (src/, Dockerfile)**

```bash
1. Dev altera src/main.ts
2. Push para main no repo Application
3. Workflow ci-cd-eks.yml executa:
   ‚úÖ Build Docker image (tag: abc123)
   ‚úÖ Push para ECR
   ‚úÖ kubectl set image deployment/fiap-soat-application ...abc123
   ‚úÖ Rollout autom√°tico
4. Nova vers√£o deployed!
```

### **Cen√°rio 3: Primeira Instala√ß√£o (cluster novo)**

```bash
1. Deploy infraestrutura:
   cd fiap-soat-k8s-terraform
   git push origin main  # workflow aplica namespace, configmap, secret, service

2. Deploy aplica√ß√£o:
   cd fiap-soat-application
   git push origin main  # workflow cria deployment + atualiza imagem
```

---

## üìä **COMPARA√á√ÉO: ANTES vs DEPOIS**

| Aspecto | ANTES (Atual) | DEPOIS (Proposto) |
|---------|---------------|-------------------|
| Nome deployment | Inconsistente (fiap-soat-nestjs vs fiap-soat-application) | Padronizado: fiap-soat-application ‚úÖ |
| Responsabilidade EKS | Aplica TODOS manifests (incluindo deployment) | Aplica APENAS configs (namespace, configmap, secret, service) ‚úÖ |
| Responsabilidade App | Build + kubectl set image | Build + kubectl apply/set image ‚úÖ |
| Conflitos | Workflows podem sobrescrever um ao outro ‚ùå | Separa√ß√£o clara de responsabilidades ‚úÖ |
| deployment.yaml | No repo EKS (longe do c√≥digo) | No repo Application (junto com c√≥digo) ‚úÖ |
| Sincroniza√ß√£o | Manual | Autom√°tica ‚úÖ |

---

## ‚ö†Ô∏è **IMPORTANTE:**

### **Ordem de Deploy Inicial (cluster novo):**

```bash
# 1. Infraestrutura PRIMEIRO (repo EKS)
kubectl apply -f namespace.yaml
kubectl apply -f configmap.yaml
kubectl apply -f secret.yaml
kubectl apply -f service.yaml

# 2. Aplica√ß√£o DEPOIS (repo Application)
# Workflow Application vai criar o deployment com a imagem correta
```

### **Regra de Ouro:**

```
üö® NUNCA aplique deployment.yaml manualmente depois do primeiro deploy!
   O CI/CD da aplica√ß√£o √© a fonte da verdade para a imagem.
```

---

## üéì **BENEF√çCIOS DA ESTRAT√âGIA:**

1. ‚úÖ **Separa√ß√£o Clara**: Infraestrutura vs Aplica√ß√£o
2. ‚úÖ **Sem Conflitos**: Workflows n√£o sobrescrevem um ao outro
3. ‚úÖ **Versionamento Correto**: Imagem sempre sincronizada com c√≥digo
4. ‚úÖ **Rastreabilidade**: Git commit ‚Üí Docker tag ‚Üí Deployment
5. ‚úÖ **Escalabilidade**: Adicionar novas aplica√ß√µes sem conflito

---

## üìù **PR√ìXIMOS PASSOS:**

1. Implementar padroniza√ß√£o de nomes
2. Atualizar workflow EKS (remover deployment.yaml)
3. Mover deployment.yaml para repo Application
4. Atualizar workflow Application (criar deployment se n√£o existir)
5. Testar fluxo completo
6. Documentar no README

---

**üéØ Resultado Final**: Workflows 100% alinhados, sem conflitos, e com responsabilidades claramente definidas!